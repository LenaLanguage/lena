; Это пример на языке Lena 5

/*
    Кто эта ваша Лена?

    Lena - компилируемый язык программирования высокого уровня
    со статической/динамической типизацией. Создавалась как
    объединение наилучшего с языков Julia, Rust и Assembler. 

    Тысяча и одна причина её попробовать:

        1. Она очень похожа на Julia или любой другой ВУ язык.
        2. Производительность сравнимая с Ассемблерным кодом,
        и ДАЖЕ (очень редко), превышающая его.
        3. Строгая, но в тоже время гибкая система типов.
        4. Гибкость, гибкость, гибкость и ещё раз гибкость.
            Позволяя программисту реализовать все идеи через различные
            конструкции, которые служат упрощением, в тоже время
            сохраняя безопасность работы подобно Rust, но не являясь
            настолько строгими чтобы вызывать дискомфорт при работе.
        5. Она похожа на всё, на чём ты когда либо мог программировать.
            
            Взгляни:

            ; Комментарии из Ассемблера

            a = 5.50; Разве не похоже на Python?

            for i in 0..10; А это не Julia-ли?

            array:i32[] = [126, 4984, 948, 45840]
            ; ^- это вообще смесь Julia и Rust

            func(a:i32, b:i32)
                .<- a + b
            ;    ^- это точно, что-то похожее на Rust или C/C++.

            ; Есть конечно-же кое что из Ассемблера, но я это показывать
            не буду.

        6. Ты быстро выучишь её. Из-за её схожести и минималистичного синтаксиса.
        7. Для всего существует свой инструмент, но зачем, когда есть Лена?
        8. Встроенные механизмы для параллизации.
        9. Встроенная стилистическая проверка кода.
        10. Больше никакого наследия, которое способно привести к плохому коду.
        11. ...

        1001. Её зовут Лена.

    
*/

; Можно создавать целочисленные переменные:

a = 10

/*

    Каким типом обладает a?
        -> Зависит от её использования:
                если ты напишешь a = 1000000
            то она автоматически изначально принимает тип u32

            Однако ты можешь указать тип самостоятельно:
                a:i32 = 10

            Но тогда нужно быть аккуратней, и следует
            после этого использовать все требования статической типизации

            Но даже запись:
                a = 10

            не гарантирует, что можно делать все операции, например:

                a = 1000
                a = "10000" <- вызовет предупреждение об изменении типа.

            Подобные операции следует делать так:

                a = 1000
                a:str = "123089"

            Теперь, после явного указания вы подтверждаете что изменили её тип.
            Важно помнить что эта гибкость позволяет эффективно без изменения
            имени переменной получить необходимый её тип.

            Пример складывания строк:

                label:str = "Дальше будет моё число:"
                new_label = label + a:str

            Из этого видно что язык обладает динамической типизацией с приоритетом
            на статическую типизацию с явным указанием типа.

        -> Нельзя не поговорить о самих типах:

            :i8, :i16, :i32, :i64 - знаковый целочисленный тип.

            :u8, :u16, :u32, :u64 - беззнакоый целочисленный тип.

            :f16, :f32, :f64 - тип с плавающей запятой.

            :str - строки.

            И, да, символьного типа нет. Если вам нужен один символ
            строки, то фактически вы получаете str с длиной в 1.

            Это были элементарные типы. А теперь кое что сложнее:

            :module - модули, это объединения содержащие свойства
            классов и структур. Об этом немного позже. В двух словах
            не описать.

            Редкое, но очень полезное:

            :any - неопределённый тип данных. Используется в очень
            исключительных случаях, когда нужно реализовать поддержку
            

            :type - это тип типа данных. Это нужно лишь для создания
            своих типов, например:
                adc_value_t:type = u8
            или-же:
                adc_value_t = u8

            Данное присвоение является исключением, так как после
            присвоения мы создаём сущность, что не будет помещена
            в память, как например модули, строки или переменные.

            Подобные, пользовательские типы очень просто определить,
            так как существует требование форматирования постфикса _t.


        -> Зачем программисту тратить драгоценное время на указание типа?



*/


; Онегин

/*

Разбить по алфавиту всё произведение Евгений Онегин.

8968654

1 Сортировка: Слева направо.
2 Сортировка: Справа налево.
3 Функция, вывести изначальный файл Онегина.
4 Бредогенератор по рифмам и размерам.

Индексация слов.

*/